/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/** HPKE (Hybrid Public Key Encryption) operations
 * https://tools.ietf.org/html/draft-irtf-cfrg-hpke-07
 */
import { concatUint8Array, stringToUint8Array } from "../util";
import { BASE_NONCE, EMPTY_BYTE_ARRAY, EAE_PRK, SHARED_SECRET, PSK_ID_HASH, INFO_HASH, SECRET, KEY, EXP, HPKE as HPKE_BUFFER, SEC, } from "../constants";
export class KEMPublicKey {
    /** Same as `encapsulate()`, and the outputs encode an assurance that the KEM
     * shared secret key was generated by the holder of the private key "skS"
     */
    authEncapsulate(skS) {
        throw new Error("This KEM does not support auth");
    }
}
export class KEMPrivateKey {
    /** Same as `decapsulate()`, and the recipient is assured that the KEM shared
     * secret was generated by the holder of the private key "skS"
     */
    authDecapsulate(enc, pkS) {
        throw new Error("This KEM does not support auth");
    }
}
const HPKE_IDENTIFIER = stringToUint8Array("HPKE-07");
// def LabeledExtract(salt, label, ikm)
export async function labeledExtract(kdf, suiteId, salt, label, ikm) {
    const labeledIkm = concatUint8Array([HPKE_IDENTIFIER, suiteId, label, ikm]);
    return kdf.extract(salt, labeledIkm);
}
// def LabeledExpand(prk, label, info, L):
export async function labeledExpand(kdf, suiteId, prk, label, info, length) {
    const labeledInfo = concatUint8Array([
        Uint8Array.from([length >> 8 & 0xff, length & 0xff]),
        HPKE_IDENTIFIER,
        suiteId, label, info,
    ]);
    return kdf.expand(prk, labeledInfo, length);
}
export class DHPrivateKey {
}
export class DHPublicKey {
}
export function makeDHKEM(dhGroup, kdf, kemId) {
    const suiteId = stringToUint8Array("KEMxx");
    suiteId[3] = kemId >> 8 & 0xff;
    suiteId[4] = kemId & 0xff;
    async function extractAndExpand(dhSecret, kemContext) {
        const eaePrk = await labeledExtract(kdf, suiteId, EMPTY_BYTE_ARRAY, // salt
        EAE_PRK, // label
        dhSecret);
        const sharedSecret = await labeledExpand(kdf, suiteId, eaePrk, // prk
        SHARED_SECRET, // label
        kemContext, // info
        kdf.hashLength);
        return sharedSecret;
    }
    class PublicKey extends KEMPublicKey {
        dhPubKey;
        constructor(dhPubKey) {
            super();
            this.dhPubKey = dhPubKey;
        }
        serialize() { return this.dhPubKey.serialize(); }
        async encapsulate(ikm) {
            const [privateKey, publicKey] = ikm ?
                await await dhGroup.deriveKeyPair(kdf, suiteId, ikm) :
                await dhGroup.generateKeyPair();
            const dhSecret = await this.dhPubKey.dh(privateKey);
            const enc = await publicKey.serialize();
            const pkRm = await this.dhPubKey.serialize();
            const kemContext = concatUint8Array([enc, pkRm]);
            const sharedSecret = await extractAndExpand(dhSecret, kemContext);
            return [sharedSecret, enc];
        }
        async authEncapsulate(skS) {
            if (!(skS instanceof PrivateKey)) {
                throw new Error("Incompatible private key type");
            }
            const [skE, pkE] = await dhGroup.generateKeyPair();
            const dhSecret = await concatUint8Array([
                await this.dhPubKey.dh(skE), await this.dhPubKey.dh(skS.dhPrivKey),
            ]);
            const enc = await pkE.serialize();
            const pkRm = await this.dhPubKey.serialize();
            const pkSm = await skS.dhPubKey.serialize();
            const kemContext = concatUint8Array([enc, pkRm, pkSm]);
            const sharedSecret = await extractAndExpand(dhSecret, kemContext);
            return [sharedSecret, enc];
        }
    }
    class PrivateKey extends KEMPrivateKey {
        dhPrivKey;
        dhPubKey;
        constructor(dhPrivKey, dhPubKey) {
            super();
            this.dhPrivKey = dhPrivKey;
            this.dhPubKey = dhPubKey;
        }
        serialize() { return this.dhPrivKey.serialize(); }
        async decapsulate(enc) {
            const pkE = await dhGroup.deserializePublic(enc);
            const dhSecret = await pkE.dh(this.dhPrivKey);
            const pkRm = await this.dhPubKey.serialize();
            const kemContext = concatUint8Array([enc, pkRm]);
            const sharedSecret = await extractAndExpand(dhSecret, kemContext);
            return sharedSecret;
        }
        async authDecapsulate(enc, pkS) {
            if (!(pkS instanceof PublicKey)) {
                throw new Error("Incompatible private key type");
            }
            const pkE = await dhGroup.deserializePublic(enc);
            const dhSecret = concatUint8Array([
                await pkE.dh(this.dhPrivKey), await pkS.dhPubKey.dh(this.dhPrivKey),
            ]);
            const pkRm = await this.dhPubKey.serialize();
            const pkSm = await pkS.dhPubKey.serialize();
            const kemContext = concatUint8Array([enc, pkRm, pkSm]);
            const sharedSecret = await extractAndExpand(dhSecret, kemContext);
            return sharedSecret;
        }
    }
    return {
        async generateKeyPair() {
            const [privateKey, publicKey] = await dhGroup.generateKeyPair();
            return [new PrivateKey(privateKey, publicKey), new PublicKey(publicKey)];
        },
        async deriveKeyPair(ikm) {
            const [privateKey, publicKey] = await dhGroup.deriveKeyPair(kdf, suiteId, ikm);
            return [new PrivateKey(privateKey, publicKey), new PublicKey(publicKey)];
        },
        async deserializePublic(enc) {
            const publicKey = await dhGroup.deserializePublic(enc);
            return new PublicKey(publicKey);
        },
        async deserializePrivate(enc) {
            const [privateKey, publicKey] = await dhGroup.deserializePrivate(enc);
            return new PrivateKey(privateKey, publicKey);
        },
        secretLength: kdf.hashLength,
        encodingLength: dhGroup.publicKeyLength,
        publicKeyLength: dhGroup.publicKeyLength,
        privateKeyLength: dhGroup.privateKeyLength,
        id: kemId,
    };
}
// 5.  Hybrid Public Key Encryption
var Mode;
(function (Mode) {
    Mode[Mode["Base"] = 0] = "Base";
    Mode[Mode["Psk"] = 1] = "Psk";
    Mode[Mode["Auth"] = 2] = "Auth";
    Mode[Mode["AuthPsk"] = 3] = "AuthPsk";
})(Mode || (Mode = {}));
const PSK_MODES = [Mode.Psk, Mode.AuthPsk];
export class HPKE {
    kem;
    kdf;
    aead;
    suiteId;
    constructor(kem, kdf, aead) {
        this.kem = kem;
        this.kdf = kdf;
        this.aead = aead;
        this.suiteId = concatUint8Array([
            HPKE_BUFFER,
            Uint8Array.from([
                kem.id >> 8 & 0xff, kem.id & 0xff,
                kdf.id >> 8 & 0xff, kdf.id & 0xff,
                aead.id >> 8 & 0xff, aead.id & 0xff,
            ]),
        ]);
    }
    verifyPskInputs(mode, psk, pskId) {
        const gotPsk = (psk.byteLength != 0);
        const gotPskId = (pskId.byteLength != 0);
        if (gotPsk != gotPskId) {
            throw new Error("Inconsistent PSK inputs");
        }
        if (gotPsk && !PSK_MODES.includes(mode)) {
            throw new Error("PSK input provided when not needed");
        }
        if (!gotPsk && PSK_MODES.includes(mode)) {
            throw new Error("Missing required PSK input");
        }
    }
    async keySchedule(mode, sharedSecret, info, psk, pskId) {
        this.verifyPskInputs(mode, psk, pskId);
        const pskIdHash = await labeledExtract(this.kdf, this.suiteId, EMPTY_BYTE_ARRAY, PSK_ID_HASH, pskId);
        const infoHash = await labeledExtract(this.kdf, this.suiteId, EMPTY_BYTE_ARRAY, INFO_HASH, info);
        const keyScheduleContext = concatUint8Array([
            Uint8Array.from([mode]), pskIdHash, infoHash,
        ]);
        const secret = await labeledExtract(this.kdf, this.suiteId, sharedSecret, SECRET, psk);
        const key = await labeledExpand(this.kdf, this.suiteId, secret, KEY, keyScheduleContext, this.aead.keyLength);
        const nonce = await labeledExpand(this.kdf, this.suiteId, secret, BASE_NONCE, keyScheduleContext, this.aead.nonceLength);
        const exporterSecret = await labeledExpand(this.kdf, this.suiteId, secret, EXP, keyScheduleContext, this.kdf.extractLength);
        return new Context(this.aead, this.kdf, this.suiteId, key, nonce, exporterSecret);
    }
    // 5.1.1 Encryption to a public key
    /** establish a context for encrypting
     */
    async setupBaseS(pkR, info, ikmE) {
        const [sharedSecret, enc] = await pkR.encapsulate(ikmE);
        const keySchedule = await this.keySchedule(Mode.Base, sharedSecret, info, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);
        return [enc, keySchedule];
    }
    /** establish a context for decrypting
     */
    async setupBaseR(enc, skR, info) {
        const sharedSecret = await skR.decapsulate(enc);
        return await this.keySchedule(Mode.Base, sharedSecret, info, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);
    }
    // 5.1.2 Authentication using a Pre-Shared Key
    async setupPskS(pkR, info, psk, pskId) {
        const [sharedSecret, enc] = await pkR.encapsulate();
        const keySchedule = await this.keySchedule(Mode.Psk, sharedSecret, info, psk, pskId);
        return [enc, keySchedule];
    }
    async setupPskR(enc, skR, info, psk, pskId) {
        const sharedSecret = await skR.decapsulate(enc);
        return await this.keySchedule(Mode.Psk, sharedSecret, info, psk, pskId);
    }
    // 5.1.3.  Authentication using an Asymmetric Key
    async setupAuthS(pkR, info, skS) {
        const [sharedSecret, enc] = await pkR.authEncapsulate(skS);
        return [
            enc,
            await this.keySchedule(Mode.Auth, sharedSecret, info, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY),
        ];
    }
    async setupAuthR(enc, skR, info, pkS) {
        const sharedSecret = await skR.authDecapsulate(enc, pkS);
        return await this.keySchedule(Mode.Auth, sharedSecret, info, EMPTY_BYTE_ARRAY, EMPTY_BYTE_ARRAY);
    }
    // 5.1.4.  Authentication using both a PSK and an Asymmetric Key
    async setupAuthPskS(pkR, info, psk, pskId, skS) {
        const [sharedSecret, enc] = await pkR.authEncapsulate(skS);
        return [
            enc,
            await this.keySchedule(Mode.AuthPsk, sharedSecret, info, psk, pskId),
        ];
    }
    async setupAuthPskR(enc, skR, info, psk, pskId, pkS) {
        const sharedSecret = await skR.authDecapsulate(enc, pkS);
        return await this.keySchedule(Mode.AuthPsk, sharedSecret, info, psk, pskId);
    }
    // 6.  Single-Shot APIs
    async sealBase(pkR, info, aad, pt) {
        const [enc, ctx] = await this.setupBaseS(pkR, info);
        const ct = await ctx.seal(aad, pt);
        return [enc, ct];
    }
    async openBase(enc, skR, info, aad, ct) {
        const ctx = await this.setupBaseR(enc, skR, info);
        return ctx.open(aad, ct);
    }
    async sealPsk(pkR, info, aad, pt, psk, pskId) {
        const [enc, ctx] = await this.setupPskS(pkR, info, psk, pskId);
        const ct = await ctx.seal(aad, pt);
        return [enc, ct];
    }
    async openPsk(enc, skR, info, aad, ct, psk, pskId) {
        const ctx = await this.setupPskR(enc, skR, info, psk, pskId);
        return ctx.open(aad, ct);
    }
    async sealAuth(pkR, info, aad, pt, skS) {
        const [enc, ctx] = await this.setupAuthS(pkR, info, skS);
        const ct = await ctx.seal(aad, pt);
        return [enc, ct];
    }
    async openAuth(enc, skR, info, aad, ct, pkS) {
        const ctx = await this.setupAuthR(enc, skR, info, pkS);
        return ctx.open(aad, ct);
    }
    async sealAuthPsk(pkR, info, aad, pt, psk, pskId, skS) {
        const [enc, ctx] = await this.setupAuthPskS(pkR, info, psk, pskId, skS);
        const ct = await ctx.seal(aad, pt);
        return [enc, ct];
    }
    async openAuthPsk(enc, skR, info, aad, ct, psk, pskId, pkS) {
        const ctx = await this.setupAuthPskR(enc, skR, info, psk, pskId, pkS);
        return ctx.open(aad, ct);
    }
}
// 5.2.  Encryption and Decryption
class Context {
    aead;
    kdf;
    suiteId;
    key;
    nonce;
    exporterSecret;
    sequence;
    constructor(aead, kdf, suiteId, key, nonce, exporterSecret) {
        this.aead = aead;
        this.kdf = kdf;
        this.suiteId = suiteId;
        this.key = key;
        this.nonce = nonce;
        this.exporterSecret = exporterSecret;
        this.sequence = new Uint8Array(aead.nonceLength);
    }
    computeNonce() {
        return this.nonce.map((el, idx) => el ^ this.sequence[idx]);
    }
    incrementSeq() {
        let i;
        for (i = this.aead.nonceLength - 1; i >= 0; i--) {
            const v = this.sequence[i];
            if (v == 0xff) {
                this.sequence[i] = 0;
            }
            else {
                this.sequence[i] = v + 1;
                break;
            }
        }
        if (i < 0) {
            throw new Error("Nonce overflow");
        }
    }
    async seal(aad, pt) {
        const ct = await this.aead.seal(this.key, this.computeNonce(), aad, pt);
        this.incrementSeq();
        return ct;
    }
    async open(aad, ct) {
        const pt = await this.aead.open(this.key, this.computeNonce(), aad, ct);
        this.incrementSeq();
        return pt;
    }
    // 5.3.  Secret Export
    async export(exporterContext, length) {
        if (length > 255 * this.kdf.extractLength) {
            throw new Error("Export length too long");
        }
        return await labeledExpand(this.kdf, this.suiteId, this.exporterSecret, SEC, exporterContext, length);
    }
}
//# sourceMappingURL=base.js.map