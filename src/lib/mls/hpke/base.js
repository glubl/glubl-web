"use strict";
/*
Copyright 2020 The Matrix.org Foundation C.I.C.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HPKE = exports.makeDHKEM = exports.DHPublicKey = exports.DHPrivateKey = exports.labeledExpand = exports.labeledExtract = exports.KEMPrivateKey = exports.KEMPublicKey = void 0;
/** HPKE (Hybrid Public Key Encryption) operations
 * https://tools.ietf.org/html/draft-irtf-cfrg-hpke-07
 */
const util_1 = require("../util");
const constants_1 = require("../constants");
class KEMPublicKey {
    /** Same as `encapsulate()`, and the outputs encode an assurance that the KEM
     * shared secret key was generated by the holder of the private key "skS"
     */
    authEncapsulate(skS) {
        throw new Error("This KEM does not support auth");
    }
}
exports.KEMPublicKey = KEMPublicKey;
class KEMPrivateKey {
    /** Same as `decapsulate()`, and the recipient is assured that the KEM shared
     * secret was generated by the holder of the private key "skS"
     */
    authDecapsulate(enc, pkS) {
        throw new Error("This KEM does not support auth");
    }
}
exports.KEMPrivateKey = KEMPrivateKey;
const HPKE_IDENTIFIER = (0, util_1.stringToUint8Array)("HPKE-07");
// def LabeledExtract(salt, label, ikm)
function labeledExtract(kdf, suiteId, salt, label, ikm) {
    return __awaiter(this, void 0, void 0, function* () {
        const labeledIkm = (0, util_1.concatUint8Array)([HPKE_IDENTIFIER, suiteId, label, ikm]);
        return kdf.extract(salt, labeledIkm);
    });
}
exports.labeledExtract = labeledExtract;
// def LabeledExpand(prk, label, info, L):
function labeledExpand(kdf, suiteId, prk, label, info, length) {
    return __awaiter(this, void 0, void 0, function* () {
        const labeledInfo = (0, util_1.concatUint8Array)([
            Uint8Array.from([length >> 8 & 0xff, length & 0xff]),
            HPKE_IDENTIFIER,
            suiteId, label, info,
        ]);
        return kdf.expand(prk, labeledInfo, length);
    });
}
exports.labeledExpand = labeledExpand;
class DHPrivateKey {
}
exports.DHPrivateKey = DHPrivateKey;
class DHPublicKey {
}
exports.DHPublicKey = DHPublicKey;
function makeDHKEM(dhGroup, kdf, kemId) {
    const suiteId = (0, util_1.stringToUint8Array)("KEMxx");
    suiteId[3] = kemId >> 8 & 0xff;
    suiteId[4] = kemId & 0xff;
    function extractAndExpand(dhSecret, kemContext) {
        return __awaiter(this, void 0, void 0, function* () {
            const eaePrk = yield labeledExtract(kdf, suiteId, constants_1.EMPTY_BYTE_ARRAY, // salt
            constants_1.EAE_PRK, // label
            dhSecret);
            const sharedSecret = yield labeledExpand(kdf, suiteId, eaePrk, // prk
            constants_1.SHARED_SECRET, // label
            kemContext, // info
            kdf.hashLength);
            return sharedSecret;
        });
    }
    class PublicKey extends KEMPublicKey {
        constructor(dhPubKey) {
            super();
            this.dhPubKey = dhPubKey;
        }
        serialize() { return this.dhPubKey.serialize(); }
        encapsulate(ikm) {
            return __awaiter(this, void 0, void 0, function* () {
                const [privateKey, publicKey] = ikm ?
                    yield yield dhGroup.deriveKeyPair(kdf, suiteId, ikm) :
                    yield dhGroup.generateKeyPair();
                const dhSecret = yield this.dhPubKey.dh(privateKey);
                const enc = yield publicKey.serialize();
                const pkRm = yield this.dhPubKey.serialize();
                const kemContext = (0, util_1.concatUint8Array)([enc, pkRm]);
                const sharedSecret = yield extractAndExpand(dhSecret, kemContext);
                return [sharedSecret, enc];
            });
        }
        authEncapsulate(skS) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!(skS instanceof PrivateKey)) {
                    throw new Error("Incompatible private key type");
                }
                const [skE, pkE] = yield dhGroup.generateKeyPair();
                const dhSecret = yield (0, util_1.concatUint8Array)([
                    yield this.dhPubKey.dh(skE), yield this.dhPubKey.dh(skS.dhPrivKey),
                ]);
                const enc = yield pkE.serialize();
                const pkRm = yield this.dhPubKey.serialize();
                const pkSm = yield skS.dhPubKey.serialize();
                const kemContext = (0, util_1.concatUint8Array)([enc, pkRm, pkSm]);
                const sharedSecret = yield extractAndExpand(dhSecret, kemContext);
                return [sharedSecret, enc];
            });
        }
    }
    class PrivateKey extends KEMPrivateKey {
        constructor(dhPrivKey, dhPubKey) {
            super();
            this.dhPrivKey = dhPrivKey;
            this.dhPubKey = dhPubKey;
        }
        serialize() { return this.dhPrivKey.serialize(); }
        decapsulate(enc) {
            return __awaiter(this, void 0, void 0, function* () {
                const pkE = yield dhGroup.deserializePublic(enc);
                const dhSecret = yield pkE.dh(this.dhPrivKey);
                const pkRm = yield this.dhPubKey.serialize();
                const kemContext = (0, util_1.concatUint8Array)([enc, pkRm]);
                const sharedSecret = yield extractAndExpand(dhSecret, kemContext);
                return sharedSecret;
            });
        }
        authDecapsulate(enc, pkS) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!(pkS instanceof PublicKey)) {
                    throw new Error("Incompatible private key type");
                }
                const pkE = yield dhGroup.deserializePublic(enc);
                const dhSecret = (0, util_1.concatUint8Array)([
                    yield pkE.dh(this.dhPrivKey), yield pkS.dhPubKey.dh(this.dhPrivKey),
                ]);
                const pkRm = yield this.dhPubKey.serialize();
                const pkSm = yield pkS.dhPubKey.serialize();
                const kemContext = (0, util_1.concatUint8Array)([enc, pkRm, pkSm]);
                const sharedSecret = yield extractAndExpand(dhSecret, kemContext);
                return sharedSecret;
            });
        }
    }
    return {
        generateKeyPair() {
            return __awaiter(this, void 0, void 0, function* () {
                const [privateKey, publicKey] = yield dhGroup.generateKeyPair();
                return [new PrivateKey(privateKey, publicKey), new PublicKey(publicKey)];
            });
        },
        deriveKeyPair(ikm) {
            return __awaiter(this, void 0, void 0, function* () {
                const [privateKey, publicKey] = yield dhGroup.deriveKeyPair(kdf, suiteId, ikm);
                return [new PrivateKey(privateKey, publicKey), new PublicKey(publicKey)];
            });
        },
        deserializePublic(enc) {
            return __awaiter(this, void 0, void 0, function* () {
                const publicKey = yield dhGroup.deserializePublic(enc);
                return new PublicKey(publicKey);
            });
        },
        deserializePrivate(enc) {
            return __awaiter(this, void 0, void 0, function* () {
                const [privateKey, publicKey] = yield dhGroup.deserializePrivate(enc);
                return new PrivateKey(privateKey, publicKey);
            });
        },
        secretLength: kdf.hashLength,
        encodingLength: dhGroup.publicKeyLength,
        publicKeyLength: dhGroup.publicKeyLength,
        privateKeyLength: dhGroup.privateKeyLength,
        id: kemId,
    };
}
exports.makeDHKEM = makeDHKEM;
// 5.  Hybrid Public Key Encryption
var Mode;
(function (Mode) {
    Mode[Mode["Base"] = 0] = "Base";
    Mode[Mode["Psk"] = 1] = "Psk";
    Mode[Mode["Auth"] = 2] = "Auth";
    Mode[Mode["AuthPsk"] = 3] = "AuthPsk";
})(Mode || (Mode = {}));
const PSK_MODES = [Mode.Psk, Mode.AuthPsk];
class HPKE {
    constructor(kem, kdf, aead) {
        this.kem = kem;
        this.kdf = kdf;
        this.aead = aead;
        this.suiteId = (0, util_1.concatUint8Array)([
            constants_1.HPKE,
            Uint8Array.from([
                kem.id >> 8 & 0xff, kem.id & 0xff,
                kdf.id >> 8 & 0xff, kdf.id & 0xff,
                aead.id >> 8 & 0xff, aead.id & 0xff,
            ]),
        ]);
    }
    verifyPskInputs(mode, psk, pskId) {
        const gotPsk = (psk.byteLength != 0);
        const gotPskId = (pskId.byteLength != 0);
        if (gotPsk != gotPskId) {
            throw new Error("Inconsistent PSK inputs");
        }
        if (gotPsk && !PSK_MODES.includes(mode)) {
            throw new Error("PSK input provided when not needed");
        }
        if (!gotPsk && PSK_MODES.includes(mode)) {
            throw new Error("Missing required PSK input");
        }
    }
    keySchedule(mode, sharedSecret, info, psk, pskId) {
        return __awaiter(this, void 0, void 0, function* () {
            this.verifyPskInputs(mode, psk, pskId);
            const pskIdHash = yield labeledExtract(this.kdf, this.suiteId, constants_1.EMPTY_BYTE_ARRAY, constants_1.PSK_ID_HASH, pskId);
            const infoHash = yield labeledExtract(this.kdf, this.suiteId, constants_1.EMPTY_BYTE_ARRAY, constants_1.INFO_HASH, info);
            const keyScheduleContext = (0, util_1.concatUint8Array)([
                Uint8Array.from([mode]), pskIdHash, infoHash,
            ]);
            const secret = yield labeledExtract(this.kdf, this.suiteId, sharedSecret, constants_1.SECRET, psk);
            const key = yield labeledExpand(this.kdf, this.suiteId, secret, constants_1.KEY, keyScheduleContext, this.aead.keyLength);
            const nonce = yield labeledExpand(this.kdf, this.suiteId, secret, constants_1.BASE_NONCE, keyScheduleContext, this.aead.nonceLength);
            const exporterSecret = yield labeledExpand(this.kdf, this.suiteId, secret, constants_1.EXP, keyScheduleContext, this.kdf.extractLength);
            return new Context(this.aead, this.kdf, this.suiteId, key, nonce, exporterSecret);
        });
    }
    // 5.1.1 Encryption to a public key
    /** establish a context for encrypting
     */
    setupBaseS(pkR, info, ikmE) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sharedSecret, enc] = yield pkR.encapsulate(ikmE);
            const keySchedule = yield this.keySchedule(Mode.Base, sharedSecret, info, constants_1.EMPTY_BYTE_ARRAY, constants_1.EMPTY_BYTE_ARRAY);
            return [enc, keySchedule];
        });
    }
    /** establish a context for decrypting
     */
    setupBaseR(enc, skR, info) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSecret = yield skR.decapsulate(enc);
            return yield this.keySchedule(Mode.Base, sharedSecret, info, constants_1.EMPTY_BYTE_ARRAY, constants_1.EMPTY_BYTE_ARRAY);
        });
    }
    // 5.1.2 Authentication using a Pre-Shared Key
    setupPskS(pkR, info, psk, pskId) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sharedSecret, enc] = yield pkR.encapsulate();
            const keySchedule = yield this.keySchedule(Mode.Psk, sharedSecret, info, psk, pskId);
            return [enc, keySchedule];
        });
    }
    setupPskR(enc, skR, info, psk, pskId) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSecret = yield skR.decapsulate(enc);
            return yield this.keySchedule(Mode.Psk, sharedSecret, info, psk, pskId);
        });
    }
    // 5.1.3.  Authentication using an Asymmetric Key
    setupAuthS(pkR, info, skS) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sharedSecret, enc] = yield pkR.authEncapsulate(skS);
            return [
                enc,
                yield this.keySchedule(Mode.Auth, sharedSecret, info, constants_1.EMPTY_BYTE_ARRAY, constants_1.EMPTY_BYTE_ARRAY),
            ];
        });
    }
    setupAuthR(enc, skR, info, pkS) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSecret = yield skR.authDecapsulate(enc, pkS);
            return yield this.keySchedule(Mode.Auth, sharedSecret, info, constants_1.EMPTY_BYTE_ARRAY, constants_1.EMPTY_BYTE_ARRAY);
        });
    }
    // 5.1.4.  Authentication using both a PSK and an Asymmetric Key
    setupAuthPskS(pkR, info, psk, pskId, skS) {
        return __awaiter(this, void 0, void 0, function* () {
            const [sharedSecret, enc] = yield pkR.authEncapsulate(skS);
            return [
                enc,
                yield this.keySchedule(Mode.AuthPsk, sharedSecret, info, psk, pskId),
            ];
        });
    }
    setupAuthPskR(enc, skR, info, psk, pskId, pkS) {
        return __awaiter(this, void 0, void 0, function* () {
            const sharedSecret = yield skR.authDecapsulate(enc, pkS);
            return yield this.keySchedule(Mode.AuthPsk, sharedSecret, info, psk, pskId);
        });
    }
    // 6.  Single-Shot APIs
    sealBase(pkR, info, aad, pt) {
        return __awaiter(this, void 0, void 0, function* () {
            const [enc, ctx] = yield this.setupBaseS(pkR, info);
            const ct = yield ctx.seal(aad, pt);
            return [enc, ct];
        });
    }
    openBase(enc, skR, info, aad, ct) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = yield this.setupBaseR(enc, skR, info);
            return ctx.open(aad, ct);
        });
    }
    sealPsk(pkR, info, aad, pt, psk, pskId) {
        return __awaiter(this, void 0, void 0, function* () {
            const [enc, ctx] = yield this.setupPskS(pkR, info, psk, pskId);
            const ct = yield ctx.seal(aad, pt);
            return [enc, ct];
        });
    }
    openPsk(enc, skR, info, aad, ct, psk, pskId) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = yield this.setupPskR(enc, skR, info, psk, pskId);
            return ctx.open(aad, ct);
        });
    }
    sealAuth(pkR, info, aad, pt, skS) {
        return __awaiter(this, void 0, void 0, function* () {
            const [enc, ctx] = yield this.setupAuthS(pkR, info, skS);
            const ct = yield ctx.seal(aad, pt);
            return [enc, ct];
        });
    }
    openAuth(enc, skR, info, aad, ct, pkS) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = yield this.setupAuthR(enc, skR, info, pkS);
            return ctx.open(aad, ct);
        });
    }
    sealAuthPsk(pkR, info, aad, pt, psk, pskId, skS) {
        return __awaiter(this, void 0, void 0, function* () {
            const [enc, ctx] = yield this.setupAuthPskS(pkR, info, psk, pskId, skS);
            const ct = yield ctx.seal(aad, pt);
            return [enc, ct];
        });
    }
    openAuthPsk(enc, skR, info, aad, ct, psk, pskId, pkS) {
        return __awaiter(this, void 0, void 0, function* () {
            const ctx = yield this.setupAuthPskR(enc, skR, info, psk, pskId, pkS);
            return ctx.open(aad, ct);
        });
    }
}
exports.HPKE = HPKE;
// 5.2.  Encryption and Decryption
class Context {
    constructor(aead, kdf, suiteId, key, nonce, exporterSecret) {
        this.aead = aead;
        this.kdf = kdf;
        this.suiteId = suiteId;
        this.key = key;
        this.nonce = nonce;
        this.exporterSecret = exporterSecret;
        this.sequence = new Uint8Array(aead.nonceLength);
    }
    computeNonce() {
        return this.nonce.map((el, idx) => el ^ this.sequence[idx]);
    }
    incrementSeq() {
        let i;
        for (i = this.aead.nonceLength - 1; i >= 0; i--) {
            const v = this.sequence[i];
            if (v == 0xff) {
                this.sequence[i] = 0;
            }
            else {
                this.sequence[i] = v + 1;
                break;
            }
        }
        if (i < 0) {
            throw new Error("Nonce overflow");
        }
    }
    seal(aad, pt) {
        return __awaiter(this, void 0, void 0, function* () {
            const ct = yield this.aead.seal(this.key, this.computeNonce(), aad, pt);
            this.incrementSeq();
            return ct;
        });
    }
    open(aad, ct) {
        return __awaiter(this, void 0, void 0, function* () {
            const pt = yield this.aead.open(this.key, this.computeNonce(), aad, ct);
            this.incrementSeq();
            return pt;
        });
    }
    // 5.3.  Secret Export
    export(exporterContext, length) {
        return __awaiter(this, void 0, void 0, function* () {
            if (length > 255 * this.kdf.extractLength) {
                throw new Error("Export length too long");
            }
            return yield labeledExpand(this.kdf, this.suiteId, this.exporterSecret, constants_1.SEC, exporterContext, length);
        });
    }
}
//# sourceMappingURL=base.js.map