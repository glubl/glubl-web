/** Key Encapsulation Mechanism
 */
export interface KEM {
    /** Generate a random key pair.
     */
    generateKeyPair(): Promise<[KEMPrivateKey, KEMPublicKey]>;
    /** Derive a key pair from the byte array `ikm`, where `ikm` SHOULD have at
     * least `privateKeyLength` bytes of entropy.
     */
    deriveKeyPair(ikm: Uint8Array): Promise<[KEMPrivateKey, KEMPublicKey]>;
    /** Parse the byte string "enc" of length "Npk" to recover a public key
     * (note: this function can raise an error upon "enc" deserialization
     * failure)
     */
    deserializePublic(enc: Uint8Array): Promise<KEMPublicKey>;
    /** Parse the byte string "enc" of length "Nsk" to recover a secret key
     * (note: this function can raise an error upon "enc" deserialization
     * failure)
     */
    deserializePrivate?(enc: Uint8Array): Promise<KEMPrivateKey>;
    /** The length in bytes of a KEM shared secret produced by this KEM. "Nsecret" */
    secretLength: number;
    /** The length in bytes of an encapsulated key produced by this KEM. "Nenc" */
    encodingLength: number;
    /** The length in bytes of an encoded public key for this KEM. "Npk" */
    publicKeyLength: number;
    /** The length in bytes of an encoded private key for this KEM. "Nsk" */
    privateKeyLength: number;
    /** The identifier for this KEM */
    id: number;
}
export declare abstract class KEMPublicKey {
    /** Produce a byte string of length `KEM.publicKeyLength` encoding the
     * public key.  The encoding can be passed to `KEM.deserializePublic` to
     * recover the public key.
     */
    abstract serialize(): Promise<Uint8Array>;
    /** Generate an ephemeral, fixed-length symmetric key (the KEM shared
     * secret) and a fixed-length encapsulation of that key that can be
     * decapsulated by the holder of the private key corresponding to "pk".
     *
     * The optional `ikm` parameter is for testing purposes
     */
    abstract encapsulate(ikm?: Uint8Array): Promise<[Uint8Array, Uint8Array]>;
    /** Same as `encapsulate()`, and the outputs encode an assurance that the KEM
     * shared secret key was generated by the holder of the private key "skS"
     */
    authEncapsulate(skS: KEMPrivateKey): Promise<[Uint8Array, Uint8Array]>;
}
export declare abstract class KEMPrivateKey {
    /** Produce a byte string of length `KEM.privateKeyLength` encoding the
     * private key.  The encoding can be passed to `KEM.deserializePrivate` to
     * recover the private key.
     */
    abstract serialize(): Promise<Uint8Array>;
    /** Use the private key "sk" to recover the ephemeral symmetric key (the
     * KEM shared secret) from its encapsulated representation "enc"
     */
    abstract decapsulate(enc: Uint8Array): Promise<Uint8Array>;
    /** Same as `decapsulate()`, and the recipient is assured that the KEM shared
     * secret was generated by the holder of the private key "skS"
     */
    authDecapsulate(enc: Uint8Array, pkS: KEMPublicKey): Promise<Uint8Array>;
}
type extractFunc = (salt: Uint8Array | undefined, ikm: Uint8Array) => Promise<Uint8Array>;
type expandFunc = (prk: Uint8Array, info: Uint8Array | undefined, length: number) => Promise<Uint8Array>;
/** Key Derivation Function
 */
export interface KDF {
    /** Extract a pseudorandom key of fixed length "Nh" bytes from input keying
     * material "ikm" and an optional byte string "salt"
     */
    extract: extractFunc;
    /** Expand a pseudorandom key "prk" using optional string "info" into "length"
     * bytes of output keying material
     */
    expand: expandFunc;
    /** The output size of the "Extract()" function in bytes. "Nh"
     */
    extractLength: number;
    /** The output length of the underlying hash function in bytes
     */
    hashLength: number;
    /** The identifier for this KEM */
    id: number;
}
export declare function labeledExtract(kdf: KDF, suiteId: Uint8Array, salt: Uint8Array | undefined, label: Uint8Array, ikm: Uint8Array): Promise<Uint8Array>;
export declare function labeledExpand(kdf: KDF, suiteId: Uint8Array, prk: Uint8Array, label: Uint8Array, info: Uint8Array | undefined, length: number): Promise<Uint8Array>;
/** Authenticated Encryption and Associated Data
 */
export interface AEAD {
    /** Encrypt and authenticate plaintext "pt" with associated data "aad"
     * using symmetric key "key" and nonce "nonce", yielding ciphertext and tag
     * "ct" (note: this function can raise a "NonceOverflowError" upon failure)
     */
    seal(key: Uint8Array, nonce: Uint8Array, aad: Uint8Array, pt: Uint8Array): Promise<Uint8Array>;
    /** Decrypt ciphertext and tag "ct" using associated data "aad" with
     * symmetric key "key" and nonce "nonce", returning plaintext message "pt"
     * (note: this function can raise an "OpenError" or "NonceOverflowError"
     * upon failure)
     */
    open(key: Uint8Array, nonce: Uint8Array, aad: Uint8Array, ct: Uint8Array): Promise<Uint8Array>;
    /** The length in bytes of a key for this algorithm. "Nk" */
    keyLength: number;
    /** The length in bytes of a nonce for this algorithm. "Nn" */
    nonceLength: number;
    /** The identifier for this KEM */
    id: number;
}
/** Diffie-Hellman group
 */
export interface DH {
    /** Generate an ephemeral key pair "(skX, pkX)" for the DH group in use.
     */
    generateKeyPair(): Promise<[DHPrivateKey, DHPublicKey]>;
    /** Generate an ephemeral key pair "(skX, pkX)" for the DH group in use,
     * based on a KDF.
     */
    deriveKeyPair(kdf: KDF, suiteId: Uint8Array, ikm: Uint8Array): Promise<[DHPrivateKey, DHPublicKey]>;
    /** Parse a byte string of length "Npk" to recover a public key (note: this
     * function can raise an error upon "enc" deserialization failure)
     */
    deserializePublic(enc: Uint8Array): Promise<DHPublicKey>;
    /** Parse a byte string of length "Nsk" to recover a private key (note: this
     * function can raise an error upon "enc" deserialization failure)
     */
    deserializePrivate(enc: Uint8Array): Promise<[DHPrivateKey, DHPublicKey]>;
    /** The length in bytes of an encoded public key
     */
    publicKeyLength: number;
    /** The length in bytes of a Diffie-Hellman shared secret produced by
     * `DHPublicKey.dh`.
     */
    secretLength: number;
    /** The length in bytes of a Diffie-Hellman private key
     */
    privateKeyLength: number;
}
export declare abstract class DHPrivateKey {
    /** Produce a byte string of length "Nsk" encoding the private key "sk"
     */
    abstract serialize(): Promise<Uint8Array>;
}
export declare abstract class DHPublicKey {
    /** Perform a non-interactive DH exchange using the private key "sk" and
     * public key "pk" to produce a Diffie-Hellman shared secret of length "Ndh"
     */
    abstract dh(privKey: DHPrivateKey): Promise<Uint8Array>;
    /** Produce a byte string of length "Npk" encoding the public key "pk"
     */
    abstract serialize(): Promise<Uint8Array>;
}
export declare function makeDHKEM(dhGroup: DH, kdf: KDF, kemId: number): KEM;
export declare class HPKE {
    readonly kem: KEM;
    readonly kdf: KDF;
    readonly aead: AEAD;
    private readonly suiteId;
    constructor(kem: KEM, kdf: KDF, aead: AEAD);
    private verifyPskInputs;
    private keySchedule;
    /** establish a context for encrypting
     */
    setupBaseS(pkR: KEMPublicKey, info: Uint8Array, ikmE?: Uint8Array): Promise<[Uint8Array, Context]>;
    /** establish a context for decrypting
     */
    setupBaseR(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array): Promise<Context>;
    setupPskS(pkR: KEMPublicKey, info: Uint8Array, psk: Uint8Array, pskId: Uint8Array): Promise<[Uint8Array, Context]>;
    setupPskR(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, psk: Uint8Array, pskId: Uint8Array): Promise<Context>;
    setupAuthS(pkR: KEMPublicKey, info: Uint8Array, skS: KEMPrivateKey): Promise<[Uint8Array, Context]>;
    setupAuthR(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, pkS: KEMPublicKey): Promise<Context>;
    setupAuthPskS(pkR: KEMPublicKey, info: Uint8Array, psk: Uint8Array, pskId: Uint8Array, skS: KEMPrivateKey): Promise<[Uint8Array, Context]>;
    setupAuthPskR(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, psk: Uint8Array, pskId: Uint8Array, pkS: KEMPublicKey): Promise<Context>;
    sealBase(pkR: KEMPublicKey, info: Uint8Array, aad: Uint8Array, pt: Uint8Array): Promise<[Uint8Array, Uint8Array]>;
    openBase(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, aad: Uint8Array, ct: Uint8Array): Promise<Uint8Array>;
    sealPsk(pkR: KEMPublicKey, info: Uint8Array, aad: Uint8Array, pt: Uint8Array, psk: Uint8Array, pskId: Uint8Array): Promise<[Uint8Array, Uint8Array]>;
    openPsk(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, aad: Uint8Array, ct: Uint8Array, psk: Uint8Array, pskId: Uint8Array): Promise<Uint8Array>;
    sealAuth(pkR: KEMPublicKey, info: Uint8Array, aad: Uint8Array, pt: Uint8Array, skS: KEMPrivateKey): Promise<[Uint8Array, Uint8Array]>;
    openAuth(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, aad: Uint8Array, ct: Uint8Array, pkS: KEMPublicKey): Promise<Uint8Array>;
    sealAuthPsk(pkR: KEMPublicKey, info: Uint8Array, aad: Uint8Array, pt: Uint8Array, psk: Uint8Array, pskId: Uint8Array, skS: KEMPrivateKey): Promise<[Uint8Array, Uint8Array]>;
    openAuthPsk(enc: Uint8Array, skR: KEMPrivateKey, info: Uint8Array, aad: Uint8Array, ct: Uint8Array, psk: Uint8Array, pskId: Uint8Array, pkS: KEMPublicKey): Promise<Uint8Array>;
}
declare class Context {
    readonly aead: AEAD;
    readonly kdf: KDF;
    readonly suiteId: Uint8Array;
    readonly key: Uint8Array;
    readonly nonce: Uint8Array;
    readonly exporterSecret: Uint8Array;
    private sequence;
    constructor(aead: AEAD, kdf: KDF, suiteId: Uint8Array, key: Uint8Array, nonce: Uint8Array, exporterSecret: Uint8Array);
    computeNonce(): Uint8Array;
    incrementSeq(): void;
    seal(aad: Uint8Array, pt: Uint8Array): Promise<Uint8Array>;
    open(aad: Uint8Array, ct: Uint8Array): Promise<Uint8Array>;
    export(exporterContext: Uint8Array, length: number): Promise<Uint8Array>;
}
export {};
